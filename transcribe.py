from __future__ import print_function
import time
import boto3
import requests
import json

def transcribeAudio(uri):
	transcribe = boto3.client('transcribe')

	suffix = str(int(round(time.time() * 1000)))
	job_name = "TranscribeJob_" + suffix

	media = uri.split(".")[-1]

	transcribe.start_transcription_job(
	    TranscriptionJobName=job_name,
	    Media={'MediaFileUri': uri},
	    MediaFormat=media,
	    LanguageCode='en-US'
	)

	# constantly gets response with a one-sec delay
	while True:
		status = transcribe.get_transcription_job(TranscriptionJobName=job_name)
		if status['TranscriptionJob']['TranscriptionJobStatus'] in ['COMPLETED', 'FAILED']:
			break
		time.sleep(1)

	# A presigned URL is generated by an AWS user who has access to the object. 

	# The presigned URL remains valid for a limited period of time after URL 
	# is generated.
	response_uri = status['TranscriptionJob']['Transcript']['TranscriptFileUri']

	if response_uri is not None:
		response = requests.get(response_uri)

	text = response.json()['results']['transcripts']
	schedule = response.json()['results']['items']
	final_text = text[0]['transcript']

	# divides text into sections by punctuations
	sections = re.split(';|,|\.|\*|\n', final_text)
	sections = list(filter(lambda x: x != "", sections))

	# computes how many words are there in each section
	lengths = [len(section.split()) for section in sections]
	valid_lengths = list(filter(lambda x: x != 0, lengths))

	# takes in account the accumulated section breaks and weights 
	fix = list(range(0, len(valid_lengths)))
	weight = [0]
	acc = 0
	for num in range(0, len(valid_lengths) -1):
		acc += valid_lengths[num]
		weight.append(acc)

	lis = [valid_lengths, fix, weight]
	positions = [sum(x) for x in zip(*lis)]
	puncs = [schedule[pos] for pos in positions]

	# finds the end_time for each section, and inserts a head for the beginning 
	# of the audio
	endstamps = [punc['end_time'] for punc in puncs]
	endstamps.insert(0, "0.00")

	# constructs a timeline with each section labelled its start time and end
	# time
	timeline = dict()

	for index in len(sections):
		timeline[sections[index]] = [endstamps[index], endstamps[index+1]]

	return json.dumps(timeline)


